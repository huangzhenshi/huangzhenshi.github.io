
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>ConcurrentHashMap | Tornado_Huang&#39;s BLOG</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Huang zhenshi">
    

    
    <meta name="description" content="概述JDK1.7一个CHM由默认16个分段组成，每一个分段默认由16个HashEntry组成（类似于16个HashMap组成一个CHM)  利用分段锁的技术，实现线程安全的分段数级别的并发写，put、remove、clear的时候加锁，size、containsValue可能会加锁 HashEntry里面的value和Next都用Volatile修饰了，保证了可见性，但是牺牲的是弱一致性：同时对某">
<meta property="og:type" content="article">
<meta property="og:title" content="ConcurrentHashMap">
<meta property="og:url" content="https://github.com/huangzhenshi/huangzhenshi.github.io.git/2018/07/30/ConcurrentHashMap/index.html">
<meta property="og:site_name" content="Tornado_Huang&#39;s BLOG">
<meta property="og:description" content="概述JDK1.7一个CHM由默认16个分段组成，每一个分段默认由16个HashEntry组成（类似于16个HashMap组成一个CHM)  利用分段锁的技术，实现线程安全的分段数级别的并发写，put、remove、clear的时候加锁，size、containsValue可能会加锁 HashEntry里面的value和Next都用Volatile修饰了，保证了可见性，但是牺牲的是弱一致性：同时对某">
<meta property="og:updated_time" content="2018-08-03T09:39:46.375Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ConcurrentHashMap">
<meta name="twitter:description" content="概述JDK1.7一个CHM由默认16个分段组成，每一个分段默认由16个HashEntry组成（类似于16个HashMap组成一个CHM)  利用分段锁的技术，实现线程安全的分段数级别的并发写，put、remove、clear的时候加锁，size、containsValue可能会加锁 HashEntry里面的value和Next都用Volatile修饰了，保证了可见性，但是牺牲的是弱一致性：同时对某">

    
    <link rel="alternative" href="/atom.xml" title="Tornado_Huang&#39;s BLOG" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Tornado_Huang&#39;s BLOG" title="Tornado_Huang&#39;s BLOG"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Tornado_Huang&#39;s BLOG">Tornado_Huang&#39;s BLOG</a></h1>
				<h2 class="blog-motto">Happy Coding</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">分类</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:github.com/huangzhenshi/huangzhenshi.github.io.git">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/07/30/ConcurrentHashMap/" title="ConcurrentHashMap" itemprop="url">ConcurrentHashMap</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Huang zhenshi" target="_blank" itemprop="author">Huang zhenshi</a>
		
  <p class="article-time">
    <time datetime="2018-07-30T07:23:06.517Z" itemprop="datePublished"> 发表于 2018-07-30</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述JDK1-7"><span class="toc-number">1.</span> <span class="toc-text">概述JDK1.7</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#方法的一句话总结1-7"><span class="toc-number">2.</span> <span class="toc-text">方法的一句话总结1.7</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#版本差异JDK1-7-VS-1-8"><span class="toc-number">3.</span> <span class="toc-text">版本差异JDK1.7 VS 1.8</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ConcurrentHashMap-的弱一致性"><span class="toc-number">4.</span> <span class="toc-text">ConcurrentHashMap 的弱一致性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CHM的结构JDK1-7"><span class="toc-number">5.</span> <span class="toc-text">CHM的结构JDK1.7</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HashEntry-JDK1-7"><span class="toc-number">6.</span> <span class="toc-text">HashEntry JDK1.7</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK1-7-put源码"><span class="toc-number">7.</span> <span class="toc-text">JDK1.7 put源码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rehash-Node-扩容-1-7"><span class="toc-number">8.</span> <span class="toc-text">rehash(Node) 扩容    1.7</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK1-7-size-函数"><span class="toc-number">9.</span> <span class="toc-text">JDK1.7 size()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#参数解释："><span class="toc-number">9.1.</span> <span class="toc-text">参数解释：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#逻辑"><span class="toc-number">9.2.</span> <span class="toc-text">逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#containsValue-函数JDK1-7"><span class="toc-number">10.</span> <span class="toc-text">containsValue()函数JDK1.7</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#isEmpty-函数JDK1-7"><span class="toc-number">11.</span> <span class="toc-text">isEmpty()函数JDK1.7</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#clear-清空CHM函数JDK1-7"><span class="toc-number">12.</span> <span class="toc-text">clear() 清空CHM函数JDK1.7</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SegmentJDK1-7"><span class="toc-number">13.</span> <span class="toc-text">SegmentJDK1.7</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Segment的modCount："><span class="toc-number">13.1.</span> <span class="toc-text">Segment的modCount：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Segment的初始化"><span class="toc-number">13.2.</span> <span class="toc-text">Segment的初始化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK1-8-特性"><span class="toc-number">14.</span> <span class="toc-text">JDK1.8 特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK1-8-Put方法"><span class="toc-number">14.1.</span> <span class="toc-text">JDK1.8 Put方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK1-8时的initTable函数"><span class="toc-number">14.2.</span> <span class="toc-text">JDK1.8时的initTable函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK1-8的一些参数"><span class="toc-number">14.3.</span> <span class="toc-text">JDK1.8的一些参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK1-8中CAS的用法"><span class="toc-number">14.4.</span> <span class="toc-text">JDK1.8中CAS的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#addCount-1-bincount"><span class="toc-number">14.5.</span> <span class="toc-text">addCount(1,bincount)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#核心函数-resizeStamp-n-n为table-length"><span class="toc-number">14.6.</span> <span class="toc-text">核心函数 resizeStamp(n);  n为table.length</span></a></li></ol></li></ol>
		
		</div>
		
		<h1 id="概述JDK1-7"><a href="#概述JDK1-7" class="headerlink" title="概述JDK1.7"></a>概述JDK1.7</h1><p>一个CHM由默认16个分段组成，每一个分段默认由16个HashEntry组成（类似于16个HashMap组成一个CHM)</p>
<ul>
<li>利用分段锁的技术，实现线程安全的分段数级别的并发写，put、remove、clear的时候加锁，size、containsValue可能会加锁</li>
<li>HashEntry里面的value和Next都用Volatile修饰了，保证了可见性，但是牺牲的是弱一致性：同时对某一个key键值对进行读写的时候，可能读不到正在写的值（1.6更明显，因为对count进行判断，JDK1.7做了改善，但是依然无法保证强一致性）</li>
</ul>
<h1 id="方法的一句话总结1-7"><a href="#方法的一句话总结1-7" class="headerlink" title="方法的一句话总结1.7"></a>方法的一句话总结1.7</h1><ol>
<li>put方法，Segment加锁，操作完之后再释放锁，可能会触发rehash()，保证了线程安全</li>
<li>get方法，getObjectVolatile的方式尝试获取最新的值，其中table、HashEntry.value、HashEntry.next都是volatile修饰的</li>
<li>rehash方法，触发的时机是达到size*loadfactor，和HashMap不一样。只独立的发生在一个Segment里面，table的大小翻倍，然后遍历获取首节点，挨个放到新数组中，是从前面开始移到链表的末位</li>
<li>remove方法，加锁的方式，找到就删除 </li>
<li>size方法：只要在一小段连续的时间内CHM未发生改动，该sum(count)值就是size值，如果变动很频繁，直接锁住，求size</li>
<li>containsValue方法遍历一次结果集，如果找到了就直接返回true，未找到则last=sum(modCount），再check遍历一次，如果2次sum一样，仍然未匹配到就返回false，超过次数后就加锁遍历。</li>
<li>isEmpty方法:sum(modcount)为0肯定为空，check一次sum(modcount)一样且count都为0就是空。最多遍历2次。</li>
<li>clear方法: 加锁把每个Segment的table的首位entry设置为null，把Segment的count归置为0，++modCount</li>
</ol>
<h1 id="版本差异JDK1-7-VS-1-8"><a href="#版本差异JDK1-7-VS-1-8" class="headerlink" title="版本差异JDK1.7 VS 1.8"></a>版本差异JDK1.7 VS 1.8</h1><ul>
<li>JDK1.7的 CHM采取的是分段锁技术，put的时候，trylock()的是Segment。JDK1.8的 CHM采取的是CAS + synchronized 来保证并发安全性,CAS操作初始化table的时候以及put时FirstNode为空的时候，synchronized加锁给FiestNode不为空的时候，而且是双重校验判断加锁的形式。</li>
<li>JDK1.7追加新结点的方式是在tab[index]的首位追加，而JDK1.8是在末位追加</li>
<li>JDK1.8的bucket当小于阈值（8和6）时是单向链表，大于阈值时是红黑树</li>
<li>JDK1.7中新的 threshold = (int)(newCapacity * loadFactor);但是在JDK1.8中，就直接写死了，  sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); //调sizeCtl为新容量0.75倍。</li>
<li>JDK1.7中其实也用到了CAS策略，ensureSegment()方法里面，判断当前非第一个Segment是否已经初始化的时候。只是JDK1.8中CAS用的更多了而已。</li>
</ul>
<h1 id="ConcurrentHashMap-的弱一致性"><a href="#ConcurrentHashMap-的弱一致性" class="headerlink" title="ConcurrentHashMap 的弱一致性"></a>ConcurrentHashMap 的弱一致性</h1><p>比如get()、size()、isEmpty()、containsValue()等等方法，都无法保证强一致性（读到的结果就是最最最新的结果），但是HashTable可以做到，牺牲了并发的性能，但是维护了强一致性</p>
<h1 id="CHM的结构JDK1-7"><a href="#CHM的结构JDK1-7" class="headerlink" title="CHM的结构JDK1.7"></a>CHM的结构JDK1.7</h1><ul>
<li>segments是由final修饰的，所以实在CHM初始化一旦设置了，就不会再变的，也就是CHM的并发读是恒定的，不会随着扩容而变化，每次扩容，都是单个Segment独立完成的操作<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">final int segmentMask;</div><div class="line">final int segmentShift;</div><div class="line">final Segment&lt;K,V&gt;[] segments;</div><div class="line">transient Set&lt;K&gt; keySet;</div><div class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</div><div class="line">transient Collection&lt;V&gt; values;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="HashEntry-JDK1-7"><a href="#HashEntry-JDK1-7" class="headerlink" title="HashEntry JDK1.7"></a>HashEntry JDK1.7</h1><p>HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">static final class HashEntry&lt;K,V&gt; &#123;</div><div class="line">        final int hash;</div><div class="line">        final K key;</div><div class="line">        volatile V value;</div><div class="line">        volatile HashEntry&lt;K,V&gt; next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="JDK1-7-put源码"><a href="#JDK1-7-put源码" class="headerlink" title="JDK1.7 put源码"></a>JDK1.7 put源码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</div><div class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value);</div><div class="line">            V oldValue;</div><div class="line">            try &#123;</div><div class="line">                HashEntry&lt;K,V&gt;[] tab = table;</div><div class="line">                int index = (tab.length - 1) &amp; hash;</div><div class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</div><div class="line">                for (HashEntry&lt;K,V&gt; e = first;;) &#123;</div><div class="line">                    if (e != null) &#123;</div><div class="line">                        K k;</div><div class="line">                        if ((k = e.key) == key ||</div><div class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</div><div class="line">                            oldValue = e.value;</div><div class="line">                            if (!onlyIfAbsent) &#123;</div><div class="line">                                e.value = value;</div><div class="line">                                ++modCount;</div><div class="line">                            &#125;</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line">                        e = e.next;</div><div class="line">                    &#125;</div><div class="line">                    else &#123;</div><div class="line">                        if (node != null)</div><div class="line">                            node.setNext(first);</div><div class="line">                        else</div><div class="line">                            node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</div><div class="line">                        int c = count + 1;</div><div class="line">                        if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</div><div class="line">                            rehash(node);</div><div class="line">                        else</div><div class="line">                            setEntryAt(tab, index, node);</div><div class="line">                        ++modCount;</div><div class="line">                        count = c;</div><div class="line">                        oldValue = null;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                unlock();</div><div class="line">            &#125;</div><div class="line">            return oldValue;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h1 id="rehash-Node-扩容-1-7"><a href="#rehash-Node-扩容-1-7" class="headerlink" title="rehash(Node) 扩容    1.7"></a>rehash(Node) 扩容    1.7</h1><ul>
<li>table的大小翻倍，然后遍历老的table，获取首节点，挨个遍历放到新数组中，是从前面开始移到末位</li>
<li>因为是2倍扩容，所以index[i]下标里面的所有entry只可能是2种位置 100001的位置或者000001的位置，JDK做了一个优化，判断lastRun</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">     @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">     private void rehash(HashEntry&lt;K,V&gt; node) &#123;</div><div class="line">         HashEntry&lt;K,V&gt;[] oldTable = table;</div><div class="line">//这里的capacity指的是table的长度，不是size啊，别搞错了</div><div class="line">         int oldCapacity = oldTable.length;</div><div class="line">         int newCapacity = oldCapacity &lt;&lt; 1;</div><div class="line">         threshold = (int)(newCapacity * loadFactor);</div><div class="line">         HashEntry&lt;K,V&gt;[] newTable =(HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];</div><div class="line">         int sizeMask = newCapacity - 1;</div><div class="line"></div><div class="line">//遍历老的table</div><div class="line">         for (int i = 0; i &lt; oldCapacity ; i++) &#123;</div><div class="line">	//然后一个个处理firstEntry，首节点为空就不处理</div><div class="line">             HashEntry&lt;K,V&gt; e = oldTable[i];</div><div class="line">             if (e != null) &#123;</div><div class="line">                 HashEntry&lt;K,V&gt; next = e.next;</div><div class="line">		//先计算first的新数组中的下标，如果next为空，该oldTable[i]扩容完成</div><div class="line">                 int idx = e.hash &amp; sizeMask;</div><div class="line">                 if (next == null)   //  Single node on list</div><div class="line">                     newTable[idx] = e;</div><div class="line">                 else &#123; // Reuse consecutive sequence at same slot</div><div class="line">			//如果该位置不止一个entry，lastRun为当前节点</div><div class="line">                     HashEntry&lt;K,V&gt; lastRun = e;</div><div class="line">			//lastIndex第一次为首位节点在新数组中的位置 可能是A 可能是B</div><div class="line">                     int lastIdx = idx;</div><div class="line">                     for (HashEntry&lt;K,V&gt; last = next;last != null;last = last.next) &#123;</div><div class="line">                         int k = last.hash &amp; sizeMask;</div><div class="line">                         if (k != lastIdx) &#123;</div><div class="line">                             lastIdx = k;</div><div class="line">                             lastRun = last;</div><div class="line">                         &#125;</div><div class="line">                     &#125;</div><div class="line">			//把该链表中末位的一串新下标的entry，赋值到未初始化的新数组中的位置</div><div class="line">                     newTable[lastIdx] = lastRun;</div><div class="line">                     </div><div class="line">			//然后遍历该firstEntry，从前到后，挨个归置到新桶当中</div><div class="line">			// Clone remaining nodes</div><div class="line">                     for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</div><div class="line">                         V v = p.value;</div><div class="line">                         int h = p.hash;</div><div class="line">                         int k = h &amp; sizeMask;</div><div class="line">                         HashEntry&lt;K,V&gt; n = newTable[k];</div><div class="line">                         newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);</div><div class="line">                     &#125;</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         int nodeIndex = node.hash &amp; sizeMask; // add the new node</div><div class="line">         node.setNext(newTable[nodeIndex]);</div><div class="line">         newTable[nodeIndex] = node;</div><div class="line">         table = newTable;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<h1 id="JDK1-7-size-函数"><a href="#JDK1-7-size-函数" class="headerlink" title="JDK1.7 size()函数"></a>JDK1.7 size()函数</h1><h2 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h2><ol>
<li>size：整个CHM的总数量</li>
<li>sum：所有Segment中的modCount的总和</li>
<li>modCount：该Segment中被修改的次数</li>
<li>count：该Segment中节点的个数</li>
</ol>
<h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><p>只要在一小段连续的时间内CHM未发生改动，该sum(count)值就是size值，如果变动很频繁，直接锁住，求size</p>
<ul>
<li>循环遍历所有非空的Segments，只有连续2次的sum(modcount)一样的话，才把sum(count）作为总size。</li>
<li>超过尝试次数，第四次循环的时候开始对所有Segment加锁来求Size<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public int size() &#123;</div><div class="line">      // Try a few times to get accurate count. On failure due to</div><div class="line">      // continuous async changes in table, resort to locking.</div><div class="line">      final Segment&lt;K,V&gt;[] segments = this.segments;</div><div class="line">      int size;</div><div class="line">      boolean overflow; // true if size overflows 32 bits</div><div class="line">      long sum;         // sum of modCounts</div><div class="line">      long last = 0L;   // previous sum</div><div class="line">      int retries = -1; // first iteration isn&apos;t retry</div><div class="line">      try &#123;</div><div class="line">          for (;;) &#123;</div><div class="line">              if (retries++ == RETRIES_BEFORE_LOCK) &#123;</div><div class="line">                  for (int j = 0; j &lt; segments.length; ++j)</div><div class="line">                      ensureSegment(j).lock(); // force creation</div><div class="line">              &#125;</div><div class="line">              sum = 0L;</div><div class="line">              size = 0;</div><div class="line">              overflow = false;</div><div class="line">              for (int j = 0; j &lt; segments.length; ++j) &#123;</div><div class="line">                  Segment&lt;K,V&gt; seg = segmentAt(segments, j);</div><div class="line">                  if (seg != null) &#123;</div><div class="line">                      sum += seg.modCount;</div><div class="line">                      int c = seg.count;</div><div class="line">                      if (c &lt; 0 || (size += c) &lt; 0)</div><div class="line">                          overflow = true;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">              if (sum == last)</div><div class="line">                  break;</div><div class="line">              last = sum;</div><div class="line">          &#125;</div><div class="line">      &#125; finally &#123;</div><div class="line">          if (retries &gt; RETRIES_BEFORE_LOCK) &#123;</div><div class="line">              for (int j = 0; j &lt; segments.length; ++j)</div><div class="line">                  segmentAt(segments, j).unlock();</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      return overflow ? Integer.MAX_VALUE : size;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="containsValue-函数JDK1-7"><a href="#containsValue-函数JDK1-7" class="headerlink" title="containsValue()函数JDK1.7"></a>containsValue()函数JDK1.7</h1><p>和size（）函数的思想一样，遍历一次结果集，如果找到了就直接返回true，未找到则last=sum(modCount），再check遍历一次，如果2次sum一样，仍然未匹配到就返回false，超过次数后就加锁遍历。</p>
<h1 id="isEmpty-函数JDK1-7"><a href="#isEmpty-函数JDK1-7" class="headerlink" title="isEmpty()函数JDK1.7"></a>isEmpty()函数JDK1.7</h1><ul>
<li>CHM是一个空的且未被操作过的CHM，所有Segment的count为0，且modcount也全为0</li>
<li>CHM是一个空的但之前有改动过，需要check一下，一小段连续的时间该CHM稳定（modcount未变，且count依旧为0)，所有Segment的count为0，但modCount不为0，比如有的线程执行了put，但是又的线程又remove了，此时count为0，或者很多操作，最后clear()了<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public boolean isEmpty() &#123;</div><div class="line">        long sum = 0L;</div><div class="line">        final Segment&lt;K,V&gt;[] segments = this.segments;</div><div class="line">        for (int j = 0; j &lt; segments.length; ++j) &#123;</div><div class="line">            Segment&lt;K,V&gt; seg = segmentAt(segments, j);</div><div class="line">            if (seg != null) &#123;</div><div class="line">                if (seg.count != 0)</div><div class="line">                    return false;</div><div class="line">                sum += seg.modCount;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (sum != 0L) &#123; // recheck unless no modifications</div><div class="line">            for (int j = 0; j &lt; segments.length; ++j) &#123;</div><div class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</div><div class="line">                if (seg != null) &#123;</div><div class="line">                    if (seg.count != 0)</div><div class="line">                        return false;</div><div class="line">                    sum -= seg.modCount;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (sum != 0L)</div><div class="line">                return false;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="clear-清空CHM函数JDK1-7"><a href="#clear-清空CHM函数JDK1-7" class="headerlink" title="clear() 清空CHM函数JDK1.7"></a>clear() 清空CHM函数JDK1.7</h1><ul>
<li>加锁的</li>
<li>把每个Segment的table的首位entry设置为null</li>
<li>把Segment的count归置为0，++modCount<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">final void clear() &#123;</div><div class="line">    lock();</div><div class="line">    try &#123;</div><div class="line">        HashEntry&lt;K,V&gt;[] tab = table;</div><div class="line">        for (int i = 0; i &lt; tab.length ; i++)</div><div class="line">            setEntryAt(tab, i, null);</div><div class="line">        ++modCount;</div><div class="line">        count = 0;</div><div class="line">    &#125; finally &#123;</div><div class="line">        unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="SegmentJDK1-7"><a href="#SegmentJDK1-7" class="headerlink" title="SegmentJDK1.7"></a>SegmentJDK1.7</h1><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">transient volatile HashEntry&lt;K,V&gt;[] table;</div><div class="line">transient int count;</div><div class="line">transient int modCount;</div><div class="line">transient int threshold;</div></pre></td></tr></table></figure>
<h2 id="Segment的modCount："><a href="#Segment的modCount：" class="headerlink" title="Segment的modCount："></a>Segment的modCount：</h2><p>该Segment被修改的总次数（The total number of mutative operations in this segment）</p>
<ul>
<li>put且新增的时候会 ++modcount</li>
<li>remove的时候会 ++modcount</li>
<li>replace的时候会 ++modcount</li>
<li>clear的时候会 ++modcount</li>
</ul>
<h2 id="Segment的初始化"><a href="#Segment的初始化" class="headerlink" title="Segment的初始化"></a>Segment的初始化</h2><ul>
<li>初始化CHM的时候，会指定segments[]为一个16数组，且只初始化segments[0]，这样提升了性能，不用CHM初始化的时候，初始所有的Sements[]，而是用到的时候再去初始化</li>
<li>里面用到了CAS，防止多个线程同时初始化这个segment<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private Segment&lt;K,V&gt; ensureSegment(int k) &#123;</div><div class="line">        final Segment&lt;K,V&gt;[] ss = this.segments;</div><div class="line">        long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset</div><div class="line">        Segment&lt;K,V&gt; seg;</div><div class="line">        if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123;</div><div class="line">            Segment&lt;K,V&gt; proto = ss[0]; // use segment 0 as prototype</div><div class="line">            int cap = proto.table.length;</div><div class="line">            float lf = proto.loadFactor;</div><div class="line">            int threshold = (int)(cap * lf);</div><div class="line">            HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];</div><div class="line">            if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</div><div class="line">                == null) &#123; // recheck</div><div class="line">                Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);</div><div class="line">                while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</div><div class="line">                       == null) &#123;</div><div class="line">                    if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))</div><div class="line">                        break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return seg;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="JDK1-8-特性"><a href="#JDK1-8-特性" class="headerlink" title="JDK1.8 特性"></a>JDK1.8 特性</h1><h2 id="JDK1-8-Put方法"><a href="#JDK1-8-Put方法" class="headerlink" title="JDK1.8 Put方法"></a>JDK1.8 Put方法</h2><ul>
<li>引入了binCount参数，纪录该tab[index]下面的结点个数，&gt;8触发链表变树、&lt;6触发树变链表<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</div><div class="line">	//如果key为null直接抛出空指针</div><div class="line">       if (key == null || value == null) throw new NullPointerException();</div><div class="line">       int hash = spread(key.hashCode());</div><div class="line">       int binCount = 0;</div><div class="line">       for (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">           Node&lt;K,V&gt; f; int n, i, fh;</div><div class="line">		//如果table为空，就初始化table，初始化的方法里面也有原子操作，保证不会同时被初始化</div><div class="line">           if (tab == null || (n = tab.length) == 0)</div><div class="line">               tab = initTable();</div><div class="line">           else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</div><div class="line">               if (casTabAt(tab, i, null,</div><div class="line">                            new Node&lt;K,V&gt;(hash, key, value, null)))</div><div class="line">                   break;                   // no lock when adding to empty bin</div><div class="line">           &#125;</div><div class="line">           else if ((fh = f.hash) == MOVED)</div><div class="line">               tab = helpTransfer(tab, f);</div><div class="line">           else &#123;</div><div class="line">               V oldVal = null;</div><div class="line">               synchronized (f) &#123;</div><div class="line">                   if (tabAt(tab, i) == f) &#123;</div><div class="line">                       if (fh &gt;= 0) &#123;</div><div class="line">                           binCount = 1;</div><div class="line">                           for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                               K ek;</div><div class="line">                               if (e.hash == hash &amp;&amp;</div><div class="line">                                   ((ek = e.key) == key ||</div><div class="line">                                    (ek != null &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                   oldVal = e.val;</div><div class="line">                                   if (!onlyIfAbsent)</div><div class="line">                                       e.val = value;</div><div class="line">                                   break;</div><div class="line">                               &#125;</div><div class="line">                               Node&lt;K,V&gt; pred = e;</div><div class="line">                               if ((e = e.next) == null) &#123;</div><div class="line">                                   pred.next = new Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                             value, null);</div><div class="line">                                   break;</div><div class="line">                               &#125;</div><div class="line">                           &#125;</div><div class="line">                       &#125;</div><div class="line">                       else if (f instanceof TreeBin) &#123;</div><div class="line">                           Node&lt;K,V&gt; p;</div><div class="line">                           binCount = 2;</div><div class="line">                           if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                                          value)) != null) &#123;</div><div class="line">                               oldVal = p.val;</div><div class="line">                               if (!onlyIfAbsent)</div><div class="line">                                   p.val = value;</div><div class="line">                           &#125;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               if (binCount != 0) &#123;</div><div class="line">                   if (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                       treeifyBin(tab, i);</div><div class="line">                   if (oldVal != null)</div><div class="line">                       return oldVal;</div><div class="line">                   break;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       addCount(1L, binCount);</div><div class="line">       return null;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="JDK1-8时的initTable函数"><a href="#JDK1-8时的initTable函数" class="headerlink" title="JDK1.8时的initTable函数"></a>JDK1.8时的initTable函数</h2><p>注意sizeCtl是全局变量，初始化之后 sizeCtl=3/4 * capacity；<br>当p=tab[index]为空的时候，不加锁的CAS的方式设置entry（如果该位置为null就设置为当前的node），成功的话，就直接break；不成功的话，就继续无限循环到成功为止<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if (tab == null || (n = tab.length) == 0)</div><div class="line">       tab = initTable();</div><div class="line">   else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</div><div class="line">       if (casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null)))</div><div class="line">           break;                   // no lock when adding to empty bin</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</div><div class="line">       return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</div><div class="line">       Node&lt;K,V&gt;[] tab; int sc;</div><div class="line">       while ((tab = table) == null || tab.length == 0) &#123;</div><div class="line">           if ((sc = sizeCtl) &lt; 0)</div><div class="line">               Thread.yield(); // lost initialization race; just spin</div><div class="line">           else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</div><div class="line">               try &#123;</div><div class="line">                   if ((tab = table) == null || tab.length == 0) &#123;</div><div class="line">                       int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</div><div class="line">                       @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</div><div class="line">                       table = tab = nt;</div><div class="line">                       sc = n - (n &gt;&gt;&gt; 2);</div><div class="line">                   &#125;</div><div class="line">               &#125; finally &#123;</div><div class="line">                   sizeCtl = sc;</div><div class="line">               &#125;</div><div class="line">               break;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       return tab;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h2 id="JDK1-8的一些参数"><a href="#JDK1-8的一些参数" class="headerlink" title="JDK1.8的一些参数"></a>JDK1.8的一些参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//用来计数，volatile</div><div class="line">private transient volatile long baseCount;</div><div class="line">//判断resize的参数</div><div class="line">private transient volatile int sizeCtl;</div></pre></td></tr></table></figure>
<h2 id="JDK1-8中CAS的用法"><a href="#JDK1-8中CAS的用法" class="headerlink" title="JDK1.8中CAS的用法"></a>JDK1.8中CAS的用法</h2><ol>
<li><p>初始化table的时候,如果sizeCtl为0表示未进行初始化， 为-1表示其它线程正在进行初始化，其它值表示已经初始化了，而且是valetile的全局变量。<br>如果未进行初始化则， CAS的方式尝试归置为 -1，成功的话，再进行一次校验，其实没有必要了，这和加锁不一样，加锁有重复执行的风险，但是CAS只会执行一次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</div><div class="line">       Node&lt;K,V&gt;[] tab; int sc;</div><div class="line">       while ((tab = table) == null || tab.length == 0) &#123;</div><div class="line">           if ((sc = sizeCtl) &lt; 0)</div><div class="line">               Thread.yield(); // lost initialization race; just spin</div><div class="line">           else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</div><div class="line">               try &#123;</div><div class="line">                   if ((tab = table) == null || tab.length == 0) &#123;</div><div class="line">                       int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</div><div class="line">                       @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</div><div class="line">                       table = tab = nt;</div><div class="line">                       sc = n - (n &gt;&gt;&gt; 2);</div><div class="line">                   &#125;</div><div class="line">               &#125; finally &#123;</div><div class="line">                   sizeCtl = sc;</div><div class="line">               &#125;</div><div class="line">               break;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       return tab;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>当插入一个元素的时候 table[index]==null的时候，也会进行CAS操作，来设置该Node为当前put的node值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</div><div class="line">               if (casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null)))</div><div class="line">                   break;                   // no lock when adding to empty bin</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="addCount-1-bincount"><a href="#addCount-1-bincount" class="headerlink" title="addCount(1,bincount)"></a>addCount(1,bincount)</h2><p>如果table[index]为null的时候 bincount=0；<br>触发扩容的条件：</p>
<ul>
<li>put后的size&gt;=sizeCtl</li>
<li>table不为空</li>
<li>table的大小小于最大容量<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private final void addCount(long x, int check) &#123;</div><div class="line">       //b=baseCount 原大小， s=b+x 表示put后的大小</div><div class="line">	CounterCell[] as; long b, s;</div><div class="line">       if ((as = counterCells) != null ||!U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123;</div><div class="line">           CounterCell a; long v; int m;</div><div class="line">           boolean uncontended = true;</div><div class="line">           if (as == null || (m = as.length - 1) &lt; 0 ||</div><div class="line">               (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||</div><div class="line">               !(uncontended =</div><div class="line">                 U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</div><div class="line">               fullAddCount(x, uncontended);</div><div class="line">               return;</div><div class="line">           &#125;</div><div class="line">           if (check &lt;= 1)</div><div class="line">               return;</div><div class="line">           s = sumCount();</div><div class="line">       &#125;</div><div class="line">       if (check &gt;= 0) &#123;</div><div class="line">           Node&lt;K,V&gt;[] tab, nt; int n, sc;</div><div class="line">           while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;</div><div class="line">                  (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</div><div class="line">               int rs = resizeStamp(n);</div><div class="line">               if (sc &lt; 0) &#123;</div><div class="line">                   if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</div><div class="line">                       sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</div><div class="line">                       transferIndex &lt;= 0)</div><div class="line">                       break;</div><div class="line">                   if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</div><div class="line">                       transfer(tab, nt);</div><div class="line">               &#125;</div><div class="line">               else if (U.compareAndSwapInt(this, SIZECTL, sc,</div><div class="line">                                            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</div><div class="line">                   transfer(tab, null);</div><div class="line">               s = sumCount();</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="核心函数-resizeStamp-n-n为table-length"><a href="#核心函数-resizeStamp-n-n为table-length" class="headerlink" title="核心函数 resizeStamp(n);  n为table.length"></a>核心函数 resizeStamp(n);  n为table.length</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">static final int resizeStamp(int n) &#123;</div><div class="line">    return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));</div><div class="line">&#125;</div></pre></td></tr></table></figure>  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://github.com/huangzhenshi/huangzhenshi.github.io.git/2018/07/30/ConcurrentHashMap/" data-title="ConcurrentHashMap | Tornado_Huang&#39;s BLOG" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2018/08/06/提升进度管理/" title="提升进度管理">
  <strong>上一篇：</strong><br/>
  <span>
  提升进度管理</span>
</a>
</div>


<div class="next">
<a href="/2018/07/17/SpringBoot监控系列/"  title="SpringBoot监控系列">
 <strong>下一篇：</strong><br/> 
 <span>SpringBoot监控系列
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2018/07/30/ConcurrentHashMap/" data-title="ConcurrentHashMap" data-url="https://github.com/huangzhenshi/huangzhenshi.github.io.git/2018/07/30/ConcurrentHashMap/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述JDK1-7"><span class="toc-number">1.</span> <span class="toc-text">概述JDK1.7</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#方法的一句话总结1-7"><span class="toc-number">2.</span> <span class="toc-text">方法的一句话总结1.7</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#版本差异JDK1-7-VS-1-8"><span class="toc-number">3.</span> <span class="toc-text">版本差异JDK1.7 VS 1.8</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ConcurrentHashMap-的弱一致性"><span class="toc-number">4.</span> <span class="toc-text">ConcurrentHashMap 的弱一致性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CHM的结构JDK1-7"><span class="toc-number">5.</span> <span class="toc-text">CHM的结构JDK1.7</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HashEntry-JDK1-7"><span class="toc-number">6.</span> <span class="toc-text">HashEntry JDK1.7</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK1-7-put源码"><span class="toc-number">7.</span> <span class="toc-text">JDK1.7 put源码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rehash-Node-扩容-1-7"><span class="toc-number">8.</span> <span class="toc-text">rehash(Node) 扩容    1.7</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK1-7-size-函数"><span class="toc-number">9.</span> <span class="toc-text">JDK1.7 size()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#参数解释："><span class="toc-number">9.1.</span> <span class="toc-text">参数解释：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#逻辑"><span class="toc-number">9.2.</span> <span class="toc-text">逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#containsValue-函数JDK1-7"><span class="toc-number">10.</span> <span class="toc-text">containsValue()函数JDK1.7</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#isEmpty-函数JDK1-7"><span class="toc-number">11.</span> <span class="toc-text">isEmpty()函数JDK1.7</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#clear-清空CHM函数JDK1-7"><span class="toc-number">12.</span> <span class="toc-text">clear() 清空CHM函数JDK1.7</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SegmentJDK1-7"><span class="toc-number">13.</span> <span class="toc-text">SegmentJDK1.7</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Segment的modCount："><span class="toc-number">13.1.</span> <span class="toc-text">Segment的modCount：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Segment的初始化"><span class="toc-number">13.2.</span> <span class="toc-text">Segment的初始化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK1-8-特性"><span class="toc-number">14.</span> <span class="toc-text">JDK1.8 特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK1-8-Put方法"><span class="toc-number">14.1.</span> <span class="toc-text">JDK1.8 Put方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK1-8时的initTable函数"><span class="toc-number">14.2.</span> <span class="toc-text">JDK1.8时的initTable函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK1-8的一些参数"><span class="toc-number">14.3.</span> <span class="toc-text">JDK1.8的一些参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK1-8中CAS的用法"><span class="toc-number">14.4.</span> <span class="toc-text">JDK1.8中CAS的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#addCount-1-bincount"><span class="toc-number">14.5.</span> <span class="toc-text">addCount(1,bincount)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#核心函数-resizeStamp-n-n为table-length"><span class="toc-number">14.6.</span> <span class="toc-text">核心函数 resizeStamp(n);  n为table.length</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="huangzhenshi" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  

  

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> FOOD CODING MUSIC IS ALL MY LIFE <br/>
			</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/huangzhenshi" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="Huang zhenshi">Huang zhenshi</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"huangzhenshi"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
